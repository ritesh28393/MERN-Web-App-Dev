****************************************************************JAVASCRIPT****************************************************************
https://medium.com/@madasamy/javascript-brief-history-and-ecmascript-es6-es7-es8-features-673973394df4
http://javascriptissexy.com/16-javascript-concepts-you-must-know-well/
https://www.freecodecamp.org/news/learn-these-core-javascript-concepts-in-just-a-few-minutes-f7a16f42c1b0/
https://medium.com/@madasamy/15-javascript-concepts-that-every-nodejs-programmer-must-to-know-6894f5157cb7
http://overapi.com/javascript
https://javascript.info/
https://www.greycampus.com/blog/programming/java-script-versions
https://www.freecodecamp.org/news/7-javascript-methods-that-will-boost-your-skills-in-less-than-8-minutes-4cc4c3dca03f/
In regular functions the this keyword represented the object that called the function, which could be the window, the document, a button or whatever. With arrow functions the this keyword always represents the object that defined the arrow function.
If you use var outside of a function, it belongs to the global scope. If you use var inside of a function, it belongs to that function. If you use var inside of a block, i.e. a for loop, the variable is still available outside of that block. var has a function scope, not a block scope.
let has a block scope. let is the block scoped version of var, and is limited to the block (or expression) where it is defined. If you use let inside of a block, i.e. a for loop, the variable is only available inside of that loop.
const is a variable that once it has been created, its value can never change. const has a block scope.

****************************************************************SASS(.scss)****************************************************************
INTRO
    Sass stands for Syntactically Awesome StyleSheet
    Sass is an extension to CSS
    Sass is a CSS pre-processor
    Sass is completely compatible with all versions of CSS
    Sass reduces repetition of CSS and therefore saves time
    Transpiling is a term for taking a source code written in one language and transform/translate it into another language. A browser does not understand Sass code. Therefore, you will need a Sass pre-processor to convert Sass code into standard CSS. This process is called transpiling.
    Comments - /*comment*/ or //comment

VARIABLES
    $variablename: value;
    example -
        $myFont: Helvetica, sans-serif;
        $myColor: red;
        $myFontSize: 18px;
        $myWidth: 680px;
        body {
            font-family: $myFont;
            font-size: $myFontSize;
            color: $myColor;
        }
        #container {
            width: $myWidth;
        }
    Sass variables are only available at the level of nesting where they are defined.
    The default behavior for variable scope can be overridden by using the !global switch. !global indicates that a variable is global, which means that it is accessible on all levels.
    Global variables should be defined outside any rules. It could be wise to define all global variables in its own file, named "_globals.scss", and include the file with the @include keyword.

NESTING
    nested rule example - In below example, ul, li, and a selectors are nested inside the nav selector
        nav {
            ul {
                margin: 0;
                padding: 0;
                list-style: none;
            }
            li {
                display: inline-block;
            }
            a {
                display: block;
                padding: 6px 12px;
                text-decoration: none;
            }
        }
    Many CSS properties have the same prefix, like font-family, font-size and font-weight or text-align, text-transform and text-overflow. With Sass you can write them as nested properties -
        font: {
            family: Helvetica, sans-serif;
            size: 18px;
            weight: bold;
        }
        text: {
            align: center;
            transform: lowercase;
            overflow: hidden;
        }

@IMPORT
    Sass keeps the CSS code DRY (Don't Repeat Yourself). One way to write DRY code is to keep related code in separate files. You can create small files with CSS snippets to include in other Sass files. Examples of such files can be: reset file, variables, colors, fonts, font-sizes, etc. 
    The SASS @import directive allows you to include the content of one file in another - @import "filename";  //You do not need to specify a file extension
    The CSS @import directive has a major drawback due to performance issues; it creates an extra HTTP request each time you call it. However, the Sass @import directive includes the file in the CSS; so no extra HTTP call is required at runtime!
    Partials -
        By default, Sass transpiles all the .scss files directly. However, when you want to import a file, you do not need the file to be transpiled directly.
        Sass has a mechanism for this: If you start the filename with an underscore, Sass will not transpile it. Files named this way are called partials in Sass - _filename.scss
        If you import the partial file, omit the underscore. Sass understands that it should import the file "_colors.scss" - @import "colors";

@MIXIN
    The @mixin directive lets you create CSS code that is to be reused throughout the website. The @include directive is created to let you use (include) the mixin.
    Example - 
        Creates a mixin named "important-text" -
            @mixin important-text {
                color: red;
                font-size: 25px;
                font-weight: bold;
                border: 1px solid blue;
            }
        Include the important-text mixin created above -
            .danger {
                @include: important-text;
                background-color: green;
            }
    Hyphens and underscores are considered to be the same. This means that @mixin important-text { } and @mixin important_text { } are considered as the same mixin!
    A mixin can also include other mixins -
        @mixin special-text {
            @include: important-text;
            @include: link;
            @include: special-border;
        }
    Passing Variables to a Mixin -
        Without default values -
            /* Define mixin with two arguments */
            @mixin bordered($color, $width) {
                border: $width solid $color;
            }
            .myArticle {
                @include bordered(blue, 1px);  // Call mixin with two values
            }
        With default values -
            @mixin bordered($color: blue, $width: 1px) {
                border: $width solid $color;
            }
            .myTips {
                @include bordered($color: orange);
            }

@EXTEND
    The @extend directive lets you share a set of CSS properties from one selector to another.
    Following Sass example first creates a basic style for buttons (this style will be used for most buttons). Then, we create one style for a "Report" button and one style for a "Submit" button. Both "Report" and "Submit" button inherit all the CSS properties from the .button-basic class, through the @extend directive -
        .button-basic  {
            border: none;
            padding: 15px 30px;
            text-align: center;
            font-size: 16px;
            cursor: pointer;
        }
        .button-report  {
            @extend .button-basic;
            background-color: red;
        }
        .button-submit  {
            @extend .button-basic;
            background-color: green;
            color: white;
        }

String functions - 
    used to manipulate and get information about strings. Sass strings are 1-based. The first character in a string is at index 1, not 0.
    https://www.w3schools.com/sass/sass_functions_string.asp

Numeric functions - 
    used to manipulate numeric values.
    https://www.w3schools.com/sass/sass_functions_numeric.asp

List functions -
    used to access values in a list, combine lists, and add items to lists
    Sass lists are immutable (they cannot change). So, the list functions that return a list, will return a new list, and not change the original list.
    Sass lists are 1-based. The first list item in a list is at index 1, not 0.
    https://www.w3schools.com/sass/sass_functions_list.asp

Map functions - 
    In Sass, the map data type represents one or more key/value pairs.
    Sass maps are immutable (they cannot change). So, the map functions that return a map, will return a new map, and not change the original map
    https://www.w3schools.com/sass/sass_functions_map.asp

Selector functions -
    used to check and manipulate selectors.
    https://www.w3schools.com/sass/sass_functions_selector.asp

Color functions -
    We can divide the color functions in Sass into three parts: Set color functions, Get color functions, and Manipulate color functions
    https://www.w3schools.com/sass/sass_functions_color.asp


****************************************************************React****************************************************************
INTRO
    React is a JavaScript library created by Facebook. React is a tool for building UI components.
    Instead of manipulating the browser's DOM directly, React creates a virtual DOM in memory, where it does all the necessary manipulating, before making the changes in the browser DOM.
    React finds out what changes have been made, and changes only what needs to be changed.
    The quickest way start learning React is to first include following 3 scripts and then write React directly in your HTML files. The first two let us write React code in our JavaScripts, and the third, Babel, allows us to write JSX syntax and ES6 in older browsers -
        <script src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
        <script src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
        <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
    React renders HTML to the web page by using a function called ReactDOM.render(HTML_CODE,HTML_ELEMENT) - html element is REPLACED by html code


REACT JSX
    JSX stands for JavaScript XML. JSX allows us to write HTML in React. JSX makes it easier to write and add HTML in React.
    JSX converts HTML tags into react elements
    With JSX - const myelement = <h1>I Love JSX!</h1>;
    Without JSX - const myelement = React.createElement('h1', {}, 'I do not use JSX!');
    Expressions in JSX - With JSX you can write expressions inside curly braces { } - const myelement = <h1>React is {5 + 5} times better with JSX</h1>;
    Inserting a Large Block of HTML - To write HTML on multiple lines, put the HTML inside ()
    One Top Level Element - The HTML code must be wrapped in ONE top level element. So if you like to write two headers, you must put them inside a parent element, like a div element. 
    Error thrown in JSX - JSX will throw an error if the HTML is not correct, or HTML elements are not properly closed, or if the HTML misses a parent element.

REACT COMPONENTS(in this tutorial we will concentrate on Class components)
    Components serve the same purpose as JavaScript functions, but work in isolation and returns HTML via a render function.
    Components come in two types, Class components and Function components.
    The component's name must start with an upper case letter
    Create a Class Component
        The component has to include the extend React.Component statement, this statement creates an inheritance to React.Component.
        The component also requires a render() method, this method returns HTML.
        Example - 
            Create a component called Car, which returns a <h2> element -
                class Car extends React.Component {
                    render() {
                        return <h2>Hi, I am a Car!</h2>;
                    }
                }
            Use this component in your application - ReactDOM.render(<Car />, document.getElementById('root'));
    Create a Function Component
        A Function component also returns HTML, and behaves pretty much the same way as a Class component, but Class components have some additions, and will be preferred in this tutorial
        Example - 
            Create a component called Car, which returns a <h2> element -
                function Car {
                    return <h2>Hi, I am a Car!</h2>;
                }
            Use this component in your application - ReactDOM.render(<Car />, document.getElementById('root'));
    Components in Components - We can refer to components inside other components
        Example - Use the Car component inside the Garage component
            class Garage extends React.Component {
                render() {
                    return (
                        <div>
                            <h1>Who lives in my Garage?</h1>
                            <Car />
                        </div>
                    );
                }
            }
            ReactDOM.render(<Garage />, document.getElementById('root'));
    Components in Files - The file must start by importing React (as before), and it has to end with the statement export default Car;
        Example - 
            Create a new file "App.js"
                import React from 'react';
                import ReactDOM from 'react-dom';
                class Car extends React.Component {
                    render() {
                        return <h2>Hi, I am a Car!</h2>;
                    }
                }
                export default Car;
            Use the Car component after importing the "App.js" file in the application
                import React from 'react';
                import ReactDOM from 'react-dom';
                import Car from './App.js';
                ReactDOM.render(<Car />, document.getElementById('root'));

REACT PROPS
    Props are arguments passed to components via HTML attributes. React Props are like function arguments in JavaScript and attributes in HTML.
    React Props are read-only! You will get an error if you try to change their value.
    Example -
        class Car extends React.Component {
            render() {
                return <h2>I am a {this.props.brand}!</h2>
            }
        }
        const myelement = <Car brand="Ford" />;
        ReactDOM.render(myelement, document.getElementById('root'));
    Pass Data - Props are also how you pass data from one component to another, as parameters
        class Car extends React.Component {
            render() {
                return <h2>I am a {this.props.brand.model}!</h2>;
            }
        }
        class Garage extends React.Component {
            render() {
                const carinfo = {name: "Ford", model: "Mustang"};
                return (
                    <div>
                    <h1>Who lives in my garage?</h1>
                    <Car brand={carinfo} />
                    </div>
                );
            }
        }
        ReactDOM.render(<Garage />, document.getElementById('root'));

REACT STATE
    React components has a built-in state object. The state object is where you store property values that belongs to the component. When the state object changes, the component re-renders.
    The state object is initialized in the constructor
    Changing the state Object - 
        To change a value in the state object, use the this.setState() method.
        Always use the setState() method to change the state object, it will ensure that the component knows its been updated and calls the render() method (and all the other lifecycle methods).
        Example -
            class Car extends React.Component {
                constructor(props) {
                    super(props);
                    this.state = {
                        brand: "Ford",
                        model: "Mustang",
                        color: "red",
                        year: 1964
                    };  
                }
                changeColor = () => {
                    this.setState({color: "blue"});
                }
                render() {
                    return (
                        <div>
                            <h1>My {this.state.brand}</h1>
                            <p>It is a {this.state.color} {this.state.model} from {this.state.year}.</p>
                            <button type="button" onClick={this.changeColor}>Change color</button>
                        </div>
                    );
                }
            }

REACT LIFECYCLE
    Each component in React has a lifecycle which you can monitor and manipulate during its three main phases. The three phases are: Mounting, Updating, and Unmounting.
    Mounting - putting elements into the DOM
        React has four built-in methods that gets called, in this order, when mounting a component -
            constructor() -  Natural place to set up the initial state and other initial values. It is called with the props, as argument, and you should always start by calling the super(props); before anything else
            getDerivedStateFromProps() - Natural place to set the state object based on the initial props. It returns an object with changes to the state.
            render() - Mandatory. This outputs HTML to the DOM
            componentDidMount() - Place where you run statements that requires that the component is already placed in the DOM.
        Example -
            class Header extends React.Component {
                constructor(props) {
                    super(props);
                    this.state = {favoritecolor: "red"};
                }
                static getDerivedStateFromProps(props, state) {
                    return {favoritecolor: props.favcol };
                }
                render() {
                    return (
                        <h1>My Favorite Color is {this.state.favoritecolor}</h1>
                    );
                }
                componentDidMount() {
                    setTimeout(() => {
                        this.setState({favoritecolor: "blue"})
                    }, 1000);
                }
            }
            ReactDOM.render(<Header favcol="yellow"/>, document.getElementById('root'));
    Updating - A component is updated whenever there is a change in the component's state or props
        React has five built-in methods that gets called, in this order, when a component is updated -
            getDerivedStateFromProps() - Same as in Mounting phase.
                Example - changeColor() won't have any effect since getDerivedStateFromProps() is called.
                    static getDerivedStateFromProps(props, state) {
                        return {favoritecolor: props.favcol };
                    }
                    changeColor = () => {
                        this.setState({favoritecolor: "blue"});
                    }
            shouldComponentUpdate() - Default value is true. You can return a Boolean value that specifies whether React should continue with the rendering or not.
                Example - changeColor() won't have any effect since shouldComponentUpdate() returns false
                    shouldComponentUpdate() {
                        return false;
                    }
                    changeColor = () => {
                        this.setState({favoritecolor: "blue"});
                    }
            render() - Mandatory. Re-render the HTML to the DOM, with the new changes.
            getSnapshotBeforeUpdate() -
                Here you have access to the props and state before the update, meaning that even after the update, you can check what the values were before the update.
                If the getSnapshotBeforeUpdate() method is present, you should also include the componentDidUpdate() method, otherwise you will get an error.
                Example -
                    getSnapshotBeforeUpdate(prevProps, prevState) {
                        document.getElementById("div1").innerHTML = "Before the update, the favorite was " + prevState.favoritecolor;
                    }
                    componentDidUpdate() {
                        document.getElementById("div2").innerHTML = "The updated favorite is " + this.state.favoritecolor;
                    }
            componentDidUpdate() - Called after the component is updated in the DOM
    Unmounting - When a component is removed from the DOM. 
        React has only one built-in method that gets called when a component is unmounted - componentWillUnmount(). This is called before Unmounting the component

REACT EVENTS
    React has the same events as HTML: click, change, mouseover etc.
    Adding Events
        React events are written in camelCase syntax - onClick instead of onclick
        React event handlers are written inside curly braces - onClick={shoot}, instead of onClick="shoot()"
    Bind this - For methods in React, the this keyword should represent the component that owns the method. That is why you should use arrow functions. With arrow functions, this will always represent the object that defined the arrow function.
        class Football extends React.Component {
            shoot = () => {
                alert(this);  // The 'this' keyword refers to the component object
            }
            render() {
                return (
                    <button onClick={this.shoot}>Take the shot!</button>
                );
            }
        }
    https://www.w3schools.com/react/react_events.asp
